# 浏览器缓存

使用浏览器缓存可以缩短网页请求资源的距离， 减少延迟， 且缓存文件可以重复利用， 减少带宽， 降低网络
负荷。

**浏览器是否使用缓存，缓存多久，是由服务器控制的。** 当浏览器请求一个网页（或者其他资源时）服务器
发回的响应头部分字段指明了有关缓存的关键信息

## 缓存机制

### 强缓存

如果强缓存命中， 浏览器直接从自己的缓存中读取资源， 不会发送请求到服务器。

当资源命中了强缓存， 最直观的表现在chrome中， 显示状态码为200， 且size显示为`from cache`

通过`Expires和Cache-Control`可以控制强缓存。

#### Expires （http1.0提出）

Expires的描述了一个绝对时间， 由服务器返回， GMT格式的字符串表示。

`Expires: Sat, 01 Dec 2029 02:42:55 GMT`

例如以上资源就表示 在2020年10月1日之前这个资源都是直接从本地加载， 无需请求服务器

但是由于在对比时间的时候， 是由服务器返回的时间与客户端的时间相比较， 所以可能会导致误差， 比如
客户端随便修改了时间， 就会影响缓存命中的结果了。

#### Cache-Control (http 1.1提出)

Cache-Control描述的是一个相对时间， 最直观的表现就是`max-age=2592000`单位是`s`， 表示
在2592000秒（30天）内都会使用这个版本的资源

常见参数
* public    允许客户端以及所有代理服务器缓存
* private   只允许客户端缓存， Cache-Control的默认值
* no-cache  是否使用缓存需要经过协商缓存来验证决定
* no-store  不适用任何缓存， 即不适用强缓存, 也不使用协商缓存
* max-age=X 缓存内容将在X秒后失效

#### 对比

当这两个header同时启用的时候， `Cache-Control`的优先级会高于`Expires`

### 协商缓存

当强缓存未命中， 浏览器一定会发送一个请求到服务器， 服务器会根据这个请求的http header判断是否
命中协商缓存， 如果命中协商缓存， 则会将这个请求返回， 但并不是返回这个资源的数据， 告诉浏览器可以
从缓存中加载这个资源。 最直观的变现为`chrome`中显示http状态为304且会四按时not modified

#### Last-Modified & Last-Modified-Since

1. 在浏览器第一次请求资源的时候， 服务器返回的`response header`里面会返回`Last-Modified`表示
这个资源在服务器上的最后的修改时间

2. 浏览器再次请求这个资源的时候，会在`resquest header`上面加上`Last-Modified-Since`这个字段

3. 服务器会根据该时间来判断资源是否有变化， 如果资源没有变化则返回304 not-modified让浏览器从缓
存中加载资源， 如果资源变化则返回新的资源

`Last-Modified`和`Last-Modified-Since`这一组配合起来使用， 只要服务器时间和客户端数据不被
篡改的情况下， 可以良好的保证协商缓存， 但是有时候也会发生服务器资源变化了，但是`Last-Modified`
没有改变的情况， 所有有时候很难排查， 于是就有了`ETag`和`If-None-Match`

#### ETag & If-None-Match

1. 浏览器第一次请求资源时， 服务器返回这个资源的同时， 在`response header`上会加上`ETag`
这个header是一个唯一标识的字符串， 一旦资源变化了这个字符串也会改变。跟变化的时候无关。解决了
`Last-Modified`的问题

2. 浏览器通过协商缓存请求服务器的时候， 会带上`If-None-Match`的字段， 就是上次返回的`ETag`

3. 浏览器会比对这个`ETag`跟这个资源生成的新的`ETag`进行比较， 相同则没有变化， 不同则变化了。
相同的话则会返回`304 Not-Modified` 与`Last-Modified`不同的是， 由于`ETag`重新生成过， 所
以哪怕这两个`ETag`相通， 也是返回

**分布式服务器上需要关闭`ETag`因为没有服务器生成的`ETag`不一样可能导致缓存失效**

