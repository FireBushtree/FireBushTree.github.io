# 跨域

## 为什么会出现跨域

由于浏览器的同源策略导致的。 同源策略限制了从同一个源加载的文档或者脚本如何与来自另外一个源的资源
进行交互，是用来隔离恶意文件的重要安全机制。 同源即表示两个源的**端口， 域名， 协议**要完全一致。

有什么不受同源限制

* 页面中的链接， 重定向， 表单提交不受同源策略限制
* 跨域资源引入如`iframe`, `script`, `link`, `img`

## JSONP

### 如何实现JSONP

实现jsonP需要前后端配合并定义好相应的数据格式（好像是批话， 反向代理也要啊）
前端： 创建一个`script`标签， 并将`src`指向需要请求的服务器地址， 最重要是需要带上一个为方法名
的请求参数。例如我有一个方法名为`print`, 约定好请求参数名为`callback`， 那么应该拼成
`url?callback=print`的格式

```javascript
function print(value) {
  console.log(value)
}

function jsonP (params) {
  const { url } = params
  const scriptEl = document.createElement('script')
  scriptEl.src = `${url}?callback=print`
  scriptEl.type = 'text/javascript'

  document.body.appendChild(scriptEl)
}

jsonP({
  url: 'http://192.168.33.10:3000'
})
```

后端： 接受请求中的`callback`函数名, 并且将需要返回的参数与函数拼接在一起。
类似于`print({ data: 111 })`的格式。

```javascript
// 这里我使用了express
const express = require('express')
const app = express()

app.get('/', (req, res) => {
  const { callback } = req.query
  res.send(`${callback}(${JSON.stringify({ data: { name: 'owen', age: 23 } })})`)
})

app.listen(3000, () => console.log('Example app listening on port 3000!'))
```

当请求结果返回后， js会自动执行该函数。

### JSONP的缺点

* 只能发送`get`请求
